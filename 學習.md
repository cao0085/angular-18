# Angular

## Component

```js
    import { Component } from "@angular/core";

    @Component({
    selector: "app-item", // 目標的根節點,類似選擇器
    standalone: true, // 是否為獨立組件
    imports: [],
    templateUrl: "./item.component.html", // 要 render 的 html element
    styleUrl: "./item.component.css", // 同上
    })
    // 傳統JS程式碼寫在這裡 
    export class ItemComponent {
    
        title = "todo";
        filter: "all" | "active" | "done" = "all";
        allItems = [
            { description: "eat", done: true },
            { description: "sleep", done: false },
            { description: "play", done: false },
            { description: "laugh", done: false },
        ];

        // 當 filter 改變屬性 return 不同值,用法和 React setState 有點像
        get items() {
            if (this.filter === "all") {
            return this.allItems;
            }
            return this.allItems.filter((item) =>
            this.filter === "done" ? item.done : !item.done
            );
        }

        addItem(description: string) {
            this.allItems.unshift({
                description,
                done: false
            });
        }
    }
```

## Directive

``` html
    <div class="main">
        <!-- 拿 Component 的 items 來當 Arrary + Render to Element -->
        <h1>My To Do List</h1>
        <h2>What would you like to do today?</h2>
        <ul>
            <li *ngFor="let item of items">{{item.description}}</li>
        </ul>

        <!-- 新增 -->
        <label for="addItemInput">What would you like to do today?</label>
        <input
            #newItem
            placeholder="add an item"
            (keyup.enter)="addItem(newItem.value); newItem.value = ''"
            class="lg-text-input"
            id="addItemInput"
        />

        <!-- 導入方法 addItem(param) -->
        <button class="btn-primary" (click)="addItem(newItem.value)">Add</button>
    </div>
```

## Form

傳統JS資料流處理: 使用者點擊輸入文字 -> 觸發 'input' event -> Calls setValue() -> 'valueChanges' event to observers -> Observers

### Angular 保持表單雙向同步的做法

- Reactive forms “ 直接改 model，畫面立即追隨 ”
    -> 使用者點擊輸入文字 -> 觸發 FormControl
        1. -> Fires a 'valueChanges' event to observers -> Observers
        2. -> Notifies the ControlValueAccessor -> Updates the DataValue

- Template-Driven forms “ NgModel 雙路同步，可能要延遲一下 ”
    -> 使用者點擊輸入文字 -> 觸發 'input' event -> ControlValueAccessor
        1. -> Calls setValue() on the FormControl -> Fires a 'valueChanges' event to observers -> Observers
        2. -> Calls viewToModelUpdate() -> NgModel -> Emits an ngModelChange event -> Component -> Component

### 

